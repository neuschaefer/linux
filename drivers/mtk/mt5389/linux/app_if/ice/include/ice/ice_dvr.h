/**
 * Copyright 2005, 2008 Cabot Communications.  All rights reserved.
 *
 * @file
 * @brief This file defines Cabot's interface from the Eclipse system to the
 * platform-specific DVR support layer.
 *
 * The ICE DVR API provides a platform-independent abstraction of the DVR
 * operations required by an Eclipse-based DVR system.
 *
 * The platform-specific implementation is responsible for :-
 * - creating, opening and closing of the file identified by Eclipse to
 *   receive the streaming data.
 * - streaming the service's data identified by Eclipse to disk in an
 *   appropriate format.
 * - playing back the recorded data.
 *
 * There are two methods for the playing back of a recording.
 * - One is used for completed recordings and takes a recording descriptor as
 *   a parameter.
 * - The other is for recordings still in progress and takes the recording's
 *   existing handle.
 *
 * There are two methods of recording a file.
 * - "standard" recordings are made to a linear data file.
 * - "timeslip" recordings are indicated by a non-zero timeslip size parameter
 *   and are recorded to a circular file (if supported), which means the
 *   recording may continue forever.
 *
 * @note An implementation of the ICE File System API is mandatory.
 * This DVR API manages the opening, closing, reading & writing of recordings
 * and timeslip files. All other file and disk functionality is managed by the
 * generic Eclipse layer making direct calls to the ICE File System API.
 *
 * @note Cabot DVR requires a primary hard drive to be available on start up.
 *       This primary drive must be drive number 0.  If drive 0 is
 *       unformatted at start up then Eclipse will format it via the ICE
 *       filesystem API.  "Formatted" from a Cabot DVR perspective means that
 *       the drive is partitioned into two and that a '/cabot' directory
 *       exists on each partition.
 */
#ifndef CABOT_ICE_ICE_DVR_H_INCLUDED
#define CABOT_ICE_ICE_DVR_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#include "ice/ice_device_number.h"
#include "ice/ice_filesystem.h"
#include "frost/frost_basictypes.h"

#include "config/include_follow_tv.h"
#define SD_BITRATE  800 // Bytes per second
#define HD_BITRATE 2800 // Bytes per second
#define ENABLE_DVR_AESDMA 1

/**
 * A Cabot DVR product will only require this number of partitions per drive.
 * The corresponding ICE filesystem implementation need only support this
 * defined number of partitions, see ice_filesystem.h.
 */
#define ICEDVR_MAX_PARTITIONS_PER_DRIVE 2

/**
 * ICE representation of a handle to a recording.
 *
 * #ICEDVR_RecordingHandle; is an opaque type, to be manipulated only by the
 * functions specified in this header file.  Its implementation is specific
 * to the target platform, though this interface is portable.
 *
 * @note Due to the handle being passed in callbacks, the implementations of 
 *       the functions specified in this header file must be able to handle
 *       gracefully the use of an ICEDVR_RecordingHandle which is no longer
 *       valid.
 */
typedef struct ICEDVR_RecordingHandle ICEDVR_RecordingHandle;

/**
* Maximum length of unique descriptor string
*/
#define ICEDVR_DESCRIPTOR_LENGTH 82

#ifdef INCLUDE_FOLLOW_TV
/**
 * Enumeration for the different types
 * of recordings which can be recorded.
 */
typedef enum ICEDVR_RecoringsType
{
    icedvr_recoringstype_recording = 0,
    icedvr_recoringstype_timeshift    
} ICEDVR_RecoringsType;
#endif
/**
 * Structure that identifies a recording uniquely across all recordings
 * available to the system.
 */
typedef struct ICEDVR_RecordingDescriptor
{
    /** Drive number as described in ice_filesystem.h */
    frost_uint8 drive_number;

    /** Drive partition letter as described in ice_filesystem.h */
    char partition;

    /** A null-terminated description string generated by Eclipse.
     * This is unique for the given drive_number, partition.
     * Typically the ICE implementation would use this as part of the
     * recording's filename or directory
     */
    char descriptor_string[ICEDVR_DESCRIPTOR_LENGTH+1];
#ifdef INCLUDE_FOLLOW_TV
    ICEDVR_RecoringsType    recording_type;
#endif
} ICEDVR_RecordingDescriptor;

/**
 * Enumeration for the different types
 * of PID streams which can be recorded.
 */
typedef enum ICEDVR_StreamType
{
    icedvr_streamtype_invalid = 0,  /**< Invalid stream entry. */
    icedvr_streamtype_mpeg2_video,  /**< Video stream (MPEG-2), occupies 
                                         value previously used by
                                         icedvr_streamtype_mpeg2_video */
    icedvr_streamtype_audio,        /**< Audio stream. */
    icedvr_streamtype_ttxt,         /**< Teletext stream. */
    icedvr_streamtype_subt,         /**< Subtitle stream. */
    icedvr_streamtype_pcr,          /**< PCR stream. */
    icedvr_streamtype_ac3,          /**< AC3 audio stream. */
    icedvr_streamtype_eac3,         /**< E-AC3 audio stream. */
    icedvr_streamtype_other,        /**< Unspecified stream type. */
    icedvr_streamtype_aac,          /**< AAC audio stream. */
    icedvr_streamtype_he_aac,       /**< HE-AAC audio stream. */
    icedvr_streamtype_ad_mpeg,      /**< MPEG audio description stream. */
    icedvr_streamtype_ad_aac,       /**< AAC audio description stream. */
    icedvr_streamtype_ad_he_aac,    /**< HE-AAC audio description stream. */
    icedvr_streamtype_ad_ac3,       /**< AC3 audio description stream. */
    icedvr_streamtype_ad_eac3,      /**< E-AC3 audio description stream */  
    icedvr_streamtype_h264_video,   /**< Video stream. (h264) */     
    icedvr_streamtype_he_aac_adts,  /**< HE-AAC (ADTS) audio stream. */
    icedvr_streamtype_ad_he_aac_adts/**< HE-AAC (ADTS) audio description stream. */
} ICEDVR_StreamType;

/**
 * Structure to hold the information for a specific PID stream.
 */
typedef struct
{
    /** The type of stream referenced by the PID. */
    ICEDVR_StreamType stream_type;

    /** The stream's PID. */
    frost_uint pid;
} ICEDVR_Stream;

/**
 * The maximum number of PID streams to be recorded for a single program.
 * Currently supported are 1 video, 1 audio, 1 subtitle, 1 PCR, 1 PAT, 1 PMT,
 * 1 audio description and one spare.
 */
#define ICEDVR_MAX_PIDS 8

/**
 * Structure to hold the stream information for a recording.
 */
typedef struct ICEDVR_RecordParams
{
    /** The number of valid PID entries present. */
    frost_uint    number_of_pids;

    /** An array of stream PID information. */
    ICEDVR_Stream pids[ICEDVR_MAX_PIDS];
} ICEDVR_RecordParams;

/**
 * Enumeration for the different modes
 * that a recording may be in.
 */
typedef enum ICEDVR_RecordingsMode
{
    ice_dvr_none = 0,    /**< No recording or playback in progress
                              (after a successful "stop" operation). */
    ice_dvr_record_only, /**< Recording only is in progress. */
    ice_dvr_play_only,   /**< Playback only is in progress. */
    ice_dvr_record_play  /**< Both recording and playback are in progress. */
} ICEDVR_RecordingsMode;

/**
 * Structure to hold information about an existing recording.
 */
typedef struct ICEDVR_RecordingInfo
{
    /** Total size of the recording, rounded up to the nearest kilobyte. */
    frost_uint32 size_kb;

    /** Current duration of the recording, in seconds. */
    frost_uint32 duration_in_seconds;

    /** Current mode of the recording. */
    ICEDVR_RecordingsMode recordings_mode;
} ICEDVR_RecordingInfo;

/**
 * Return codes from the ICEDVR_Init() initialisation function.
 */
typedef enum ICEDVR_InitResult
{
    /** Initialisation failed. */
    icedvr_init_fail = 0,           

    /** Initialisation succeeded, or the DVR is already initialised */
    icedvr_init_success,            

    /**
     * Re-initialise system requested.
     *
     * This is returned if the ICE implementation detected a request to
     * re-initialise the system back to "factory settings".
     * (Eclipse will return a dvr_reinitialise_requested status to the UIApp
     * on a call to EASIDvrInterface::getDvrModuleStatus()
     */
    icedvr_init_reinitialise_system 
} ICEDVR_InitResult;

#if (ENABLE_DVR_AESDMA)
typedef enum
{
    E_DECRYPT,
    E_ENCRYPT
} ICEDVR_enAESDMAMode;
#endif

/***********************************************************/
/****************** GENERAL FUNCTIONS **********************/
/***********************************************************/

/**
 * @brief Check if DVR functionality is enabled.
 *
 * @return true if DVR functionality is enabled.
 */

frost_bool ICEDVR_Enabled(void);

void ICEDVR_SetEnableAESDMA(frost_bool b_Enable);

/**
 * @brief Initialise the ICE DVR component.
 *
 * This function must be called prior to any calls to any other ICE DVR functions.
 * If called again the call is silently ignored.
 *
 * @param streaming_path Path where the ICE implementation must store streaming files.
 *
 * @return icedvr_init_success if initialisation is successful or if the DVR is
 *                             already initialised,
 * icedvr_init_fail if initialisation failed,
 * icedvr_init_reinitialise_system if the ICE implementation detected a request
 *                                 to re-initialise the system back to "factory
 *                                 settings" (Eclipse will return a dvr_reinitialise_requested
 *                                 status to the UIApp on a call to
 *                                 UIDvrInterface::getDvrModuleStatus()
 */
ICEDVR_InitResult ICEDVR_Init(const char * streaming_path);

/**
 * @brief Get information about a recording.
 *
 * This function returns information about an existing recording (which may
 * still be in progress).
 *
 * For a completed recording, the duration_in_seconds is the total duration
 * of the recording.  For a recording still in progress it is the duration so
 * far recorded at the time of the call.
 *
 * @param descriptor     Recording descriptor as provided by Eclipse to
 *                       ICEDVR_RecordStart().
 * @param recording_info Structure to receive the recording information.
 * @return frost_true if the recording_info was successfully obtained,
 *         else frost_false (the contents of recording_info are undefined).
 */
frost_bool ICEDVR_GetRecordingInfo(ICEDVR_RecordingDescriptor descriptor,
                                   ICEDVR_RecordingInfo *recording_info);


/**
 * @brief Delete the files associated with a recording.
 *
 * This function deletes all files and directories created by the ICE
 * implementation as a result of a call to ICEDVR_RecordStart().
 *
 * Any existing ICEDVR_RecordingHandle associated with the recording will be
 * released and its resources freed.
 *
 * Eclipse will not call this function for a recording or playback that is in
 * progress.
 *
 * @param descriptor     Recording descriptor as provided by Eclipse to
 *                       ICEDVR_RecordStart().
 * @return frost_true if the recording was successfully deleted,
 *         else frost_false.
 */
frost_bool ICEDVR_DeleteRecording(ICEDVR_RecordingDescriptor descriptor);


/**
 * ICEDVR_FindHandle abstracts a handle to a DVR recording find session.
 *
 * This is an opaque type, to be manipulated only by the functions specified 
 * in this header file.  Its implementation is specific to the target
 * platform, though this interface is portable.
 */
typedef struct ICEDVR_FindHandle ICEDVR_FindHandle;

/**
 * @brief Find the first recording descriptor.
 *
 * This function retrieves the recording descriptor for the first recording
 * on a given drive and partition.
 * @param descriptor  The drive_number & partition fields specify where
 *                    to check for the recording.
 *                    Field descriptor_string receives the name of the 
 *                    found recording.
 * @return Valid ICEDVR_FindHandle if a recording exists,
 *         else zero if there are no recordings to retrieve
 */
ICEDVR_FindHandle* ICEDVR_FindFirstRecording(
        ICEDVR_RecordingDescriptor *descriptor);

/**
 * @brief Find the next recording descriptor.
 *
 * This function retrieves the recording descriptor for the next recording.
 * @param handle   ICEDVR_FindHandle retrieved from a previous call
 *                 to ICEDVR_FindFirstRecording().
 * @param descriptor  Field descriptor_string receives the name of the 
 *                    found recording.
 *                    (The drive_number & partition fields are unused).
 * @return frost_true if the retrieved_descriptor was successfully filled,
 *         else frost_false if there are no more recordings to retrieve
 *                          (contents of retrieved_descriptor are undefined).
 */
frost_bool ICEDVR_FindNextRecording(
        ICEDVR_FindHandle* handle,
        ICEDVR_RecordingDescriptor *descriptor);

/**
 * @brief Close a DVR find recordings session.
 *
 * Releases all resources for the DVR find recordings session.
 * After a call to this function the ICEDVR_FindHandle is no longer valid and
 * must not be used.
 * @param handle A handle returned from a call to ICEDVR_FindFirstRecording.
 * @return frost_true on success,
 *         else frost_false.
 */
frost_bool ICEDVR_FindClose(ICEDVR_FindHandle* handle);

/**
 * @brief Perform housekeeping on a partition.
 *
 * This function gives the ICE implementation the opportunity to 
 * perform housekeeping tasks on the partition used for streaming files.
 * The implementation may choose to do nothing.
 * Or may for example, remove any unrecognised files & directories,
 * zero-length files, etc.
 * Its purpose is to make the system "self-maintaining" in the event
 * of power-outages, bugs, etc.
 * Eclipse will not call this function whilst recording to, or playback
 * from the partition is in progress.
 * @param drive_number  Drive number as described in ice_filesystem.h
 * @param partition     Drive partition letter as described in
 *                      ice_filesystem.h
 * @result frost_true if the housekeeping was completed successfully,
 *         else frost_false.
 */
frost_bool ICEDVR_PerformPartitionHousekeep(frost_uint8 drive_number,
                                            char partition);


/***********************************************************/
/********************* RECORDING CONTROL *******************/
/***********************************************************/

/**
 * Enumeration of possible DVR events passed to ICEDVR_RecordCallbackFunction.
 */
typedef enum ICEDVR_RecordEvent
{
    /**
     * Recording device has started recording
     * after a successful call to ICEDVR_RecordStart().
     */
    icedvr_record_event_started,

    /**
     * Recording device has completed the stop operation after a successful
     * call to ICEDVR_RecordStop().
     *
     * On return from the callback function, if the handle is not currently
     * playing back the recording then the associated ICEDVR_RecordingHandle
     * will be closed & any resources freed.
     */
    icedvr_record_event_stopped,

    /**
     * Recording device has encountered an error while stopping recording
     *
     */
    icedvr_record_event_stopped_failed,

    /**
     * The write pointer in a circular file has reached the file's read
     * pointer, or if circular files are not supported then the file has
     * reached its maximum permitted size.
     * Prior to calling the callback, the ICE implementation must cease
     * recording.  The ICE implementation must wait until Eclipse calls
     * ICEDVR_RecordStop() before it calls the icedvr_record_event_stopped
     * callback, frees the handle, and changes the recordings_mode.
     */
    icedvr_record_event_end_of_storage,

    /**
     * Recording device has encountered an unrecoverable error processing
     * the transport stream.
     * Prior to calling the callback, the ICE implementation must cease
     * recording.  The ICE implementation must wait until Eclipse calls
     * ICEDVR_RecordStop() before it calls the icedvr_record_event_stopped
     * callback, frees the handle, and changes the recordings_mode.
     */
    icedvr_record_event_process_error,

    /**
     * Recording device has encountered an error writing to the
     * recording file.
     * Prior to calling the callback, the ICE implementation must cease
     * recording.  The ICE implementation must wait until Eclipse calls
     * ICEDVR_RecordStop() before it calls the icedvr_record_event_stopped
     * callback, frees the handle, and changes the recordings_mode.
     */
    icedvr_record_event_write_failed,

    /**
     * Recording device has encountered a disk full error writing to the
     * recording file.
     * Prior to calling the callback, the ICE implementation must cease
     * recording.  The ICE implementation must wait until Eclipse calls
     * ICEDVR_RecordStop() before it calls the icedvr_record_event_stopped
     * callback, frees the handle, and changes the recordings_mode.
     */
    icedvr_record_event_disk_full

} ICEDVR_RecordEvent;

/**
 * Callback function to inform Eclipse of a DVR event during recording.
 *
 * This function will not call back into any ICEDVR_ functions.
 *
 * This function may block (e.g. on mutexes and message queues).  Do not call
 * this in real-time code, use a separate thread.
 *
 * The ICE implementation must not call this function directly from within
 * any ICEDVR_ functions - it must be called from a separate thread.
 *
 * When this function is called, Eclipse will take a mutex that is also held
 * whilst calling ICEDVR_ functions.  As a consequence, if the ICE
 * implementation holds any locks whilst calling this function, it must never
 * take those locks inside any ICEDVR_ function.  If you break this rule then
 * the system will intermittently deadlock.  (This applies even if you use
 * recursive mutexes).
 *
 * @param handle          The handle of the recording generating the event.
 * @param event           The ICEDVR_RecordEvent generated.
 * @param user_data       The user_data parameter passed to
 *                        ICEDVR_RecordStart().
 * @param recordings_mode The recording's current ICEDVR_RecordingsMode.
 */
typedef void (*ICEDVR_RecordCallbackFunction)(
                    ICEDVR_RecordingHandle *handle,
                    ICEDVR_RecordEvent event,
                    void* user_data,
                    ICEDVR_RecordingsMode recordings_mode);

/**
 * @brief Start a recording.
 *
 * This function initiates the process of making a new recording and returns.
 * Later, when the actual recording process is underway, the implementation
 * must asynchronously call the supplied ICEDVR_RecordCallbackFunction with
 * the event 'icedvr_record_event_started'.  The ICEDVR_RecordingsMode will
 * then be 'ice_dvr_record_only'.  Note that it is not possible for the
 * implementation to call the ICEDVR_RecordCallbackFunction from within
 * ICEDVR_RecordStart.
 *
 * If a recording already exists with the same descriptor then this will be
 * silently overwritten.
 *
 * @param descriptor        Unique recording descriptor provided by Eclipse.
 * @param tuner_id          Identifies which tuner to record from.
 * @param record_params     The PID streams to be recorded.
 * @param callback          Function to notify Eclipse of ICEDVR_RecordEvents.
 * @param user_data         This pointer must be passed unmodified to
 *                          ICEDVR_RecordCallbackFunction as the user_data
 *                          parameter.
 * @param timeslip_length_secs  Zero if this is not a timeslip recording.
 *                            If non-zero then this is a timeslip recording and
 *                            this is the length of the circular file in seconds, or the
 *                            maximum file length if circular files are not
 *                            supported.
 *
 * @return An open recording handle or zero on failure.
 */
ICEDVR_RecordingHandle* ICEDVR_RecordStart(
                            ICEDVR_RecordingDescriptor descriptor,
                            ICE_DeviceSource tuner_id,
                            const ICEDVR_RecordParams *record_params,
                            ICEDVR_RecordCallbackFunction callback,
                            void *user_data,
                            frost_uint32 timeslip_length_secs);

/**
 * @brief Stop a recording.
 * 
 * This function requests the stopping of a recording and returns.
 * 
 * When recording has successfully stopped then ICEDVR_RecordCallbackFunction
 * is called with 'icedvr_record_event_stopped'.
 *
 * If the handle was only recording then the mode will be 'ice_dvr_none'.
 * On return from the callback the ICEDVR_RecordingHandle and any
 * allocated resources will be freed.
 *
 * If the handle was also playing back then the mode will be
 * 'ice_dvr_play_only'.
 * 
 * @param handle An ICEDVR_RecordingHandle identifying which recording to
 *               stop.
 * @return frost_false if the handle entry is not currently being recorded.
 */
frost_bool ICEDVR_RecordStop(ICEDVR_RecordingHandle *handle);


/***********************************************************/
/********************* PLAYBACK CONTROL ********************/
/***********************************************************/

/**
 * Enumeration of possible DVR events passed to the
 * ICEDVR_PlaybackCallbackFunction.
 */
typedef enum ICEDVR_PlaybackEvent
{
    /**
    * Playback device has completed the start operation & the data is now
    * playing back after a successful call to ICEDVR_PlaybackStart().
    */
    icedvr_play_event_started,

    /**
    * Playback device has completed the stop operation after a successful
    * call to ICEDVR_PlaybackStop().
    *
    * On return from the callback function, if the handle is not currently
    * recording then the associated ICEDVR_RecordingHandle will be closed and
    * any resources freed.
    */
    icedvr_play_event_stopped,

    /**
    * Playback device has reached the beginning of the recorded file when in
    * reverse playback mode.
    *
    * Prior to calling the callback, the ICE implementation must set the
    * playback speed to 0 (as if ICEDVR_PlaybackSetSpeed(0) had been called),
    * so the playback is in a paused state.
    */
    icedvr_play_event_no_data_beginning,

    /**
    * Playback device has reached the end of the recorded file when in
    * forward playback mode, or in a circular file the read pointer has
    * reached the write pointer.
    *
    * Prior to calling the callback, the ICE implementation must set the
    * playback speed to 0 (as if ICEDVR_PlaybackSetSpeed(0) had been called),
    * so the playback is in a paused state.
    */
    icedvr_play_event_no_data_end,

    /**
    * Playback device has encountered an error reading the recorded file.
    *
    * Prior to calling the callback, the ICE implementation must set the
    * playback speed to 0 (as if ICEDVR_PlaybackSetSpeed(0) had been called),
    * so the playback is in a paused state.
    */
    icedvr_play_event_read_failed,

    /**
    * Playback device has encountered an irrecoverable error playing back
    * the recorded streams.
    *
    * Prior to calling the callback, the ICE implementation must set the
    * playback speed to 0 (as if ICEDVR_PlaybackSetSpeed(0) had been called),
    * so the playback is in a paused state.
    */
    icedvr_play_event_process_error

} ICEDVR_PlaybackEvent;

/**
 * Callback function to inform Eclipse of a DVR event during playback.
 *
 * This function will not call back into any ICEDVR_ functions.
 *
 * This function may block (e.g. on mutexes and message queues).  Do not call
 * this in real-time code, use a separate thread.
 *
 * The ICE implementation must not call this function directly from within
 * any ICEDVR_ functions - it must be called from a separate thread.
 *
 * When this function is called, Eclipse will take a mutex that is also held
 * whilst calling ICEDVR_ functions.  As a consequence, if the ICE
 * implementation holds any locks whilst calling this function, it must never
 * take those locks inside any ICEDVR_ function.  If you break this rule then
 * the system will intermittently deadlock.  (This applies even if you use
 * recursive mutexes).
 *
 * @param handle          The handle of the recording generating the event.

 * @param event           The ICEDVR_PlaybackEvent generated.
 * @param user_data       The user_data parameter passed to
 *                        ICEDVR_PlaybackStart.
 * @param recordings_mode The recording's current ICEDVR_RecordingsMode.
 */
typedef void (*ICEDVR_PlaybackCallbackFunction)(
                            ICEDVR_RecordingHandle *handle,
                            ICEDVR_PlaybackEvent event,
                            void* user_data,
                            ICEDVR_RecordingsMode recordings_mode);



/**
 * @brief Start playback of a previous recording
 *
 * This function begins a playback of a previous recording and returns.
 * When the actual playback process starts the implementation will send 
 * 'icedvr_play_event_started'.
 *
 * The playback always starts at normal speed, i.e. the equivalent of
 * ICEDVR_PlaybackSetSpeed(..., 1000).
 *
 * @note The ICEDVR_RecordingsMode passed in the callback will always be
 *       'ice_dvr_play_only'.
 *
 * @note Following a call to ICEDVR_PlaybackStart, Eclipse will start decoding
 *       the AV components using subsequent calls through the ICE_Audio and
 *       ICE_Video APIs.  The stream_pids parameter passed to this function
 *       can be ignored if not required.
 * 
 * @note There will only be one active playback at one time.
 *
 * @param start_point   Play the recording from here (in seconds)
 * @param descriptor    The unique Recording descriptor as provided by Eclipse
 *                      to ICEDVR_RecordStart().
 * @param record_params The PID streams in the recording to be played back.
 *                      (This is a hint, ICE implementations may choose to
 *                      ignore it).
 * @param callback      Function to notify Eclipse of ICEDVR_PlaybackEvent's.
 * @param user_data     This pointer must be passed unmodified to the
 *                      ICEDVR_PlaybackCallbackFunction as the user_data
 *                      parameter.
 *
 * @return An open recording handle or zero on failure.
 */
ICEDVR_RecordingHandle* ICEDVR_PlaybackStart(
        frost_int32 start_point,
        ICEDVR_RecordingDescriptor descriptor,
        const ICEDVR_RecordParams *record_params,
        ICEDVR_PlaybackCallbackFunction callback,
        void *user_data);

/**
 * @brief Start playback from an in-progress recording or from a timeslip.
 *
 * This function begins playback from a file that is currently recording
 * (either a standard linear recording or a timeslip file), and returns.
 * When the actual playback process starts the implementation will send 
 * 'icedvr_play_event_started'.
 * The ICEDVR_RecordingsMode will be set to 'ice_dvr_record_play'.
 *
 * @note Following a call to ICEDVR_PlaybackStart, Eclipse will start decoding
 *       the AV components using subsequent calls through the ICE_Audio and
 *       ICE_Video APIs.  The stream_pids parameter passed to this function
 *       can be ignored if not required.
 * 
 * @note There will only be one active playback at one time.
 *
 * @param handle                An ICEDVR_RecordingHandle returned from
 *                              ICEDVR_RecordStart().
 * @param record_params         The PID streams in the recording to be played
 *                              back.  (This is a hint, ICE implementations
 *                              may choose to ignore it).
 * @param playback_callback     Function to notify Eclipse of
 *                              ICEDVR_PlaybackEvent.
 * @param user_data             This pointer must be passed unmodified to
 *                              ICEDVR_PlaybackCallbackFunction as the
 *                              user_data parameter.
 * @param speed_per_thousandths Playback speed in per-thousandths.  Eg. 2000
 *                              is double speed, 500 is half speed, Pause is
 *                              zero, -3000 is triple speed in reverse.
 * @param seconds_into_recording Number of seconds into the recording.
 *        For a linear file this is the number of seconds from the start of
 *        recording. Passing a negative value is undefined.
 *
 *        For a circular file, a value of zero indicates the "oldest" part of
 *        the recording.  Positive values indicate the number of seconds
 *        forward in time from that point.  Negative values indicate the 
 *        number of seconds backward in time from the current write point.
 *        So -30 indicates "30 seconds ago", and -1 indicates the most recent
 *        part of the recording (such that the read position is just behind
 *        the write position with the minimum delay from the live broadcast).
 *
 * @note An "out of range" value for seconds_into_recording sets the position
 *       to the closest valid value.
 *
 * @return frost_true if successful.
 */
frost_bool ICEDVR_RecordingPlaybackStart(
        ICEDVR_RecordingHandle *handle,
        const ICEDVR_RecordParams *record_params,
        ICEDVR_PlaybackCallbackFunction playback_callback,
        void *user_data,
        frost_int32 speed_per_thousandths,
        frost_int32 seconds_into_recording);

/**
 * @brief Get the number of seconds into the playback.
 *
 * The playback position is represented by the number of seconds
 * into the playback.
 *
 * For a linear file this will always be a positive value representing
 * the time offset from the start of the file.
 *
 * For a circular file this will always be a negative value
 * representing the time offset between the current read and
 * the current write position. -1 would represent the most
 * "up to date" playback possible.
 *
 * @param handle Handle to the current playback.
 * @return The number of seconds into the playback.
 */
frost_int32 ICEDVR_PlaybackGetTime(ICEDVR_RecordingHandle *handle);

frost_int32 ICEDVR_PlaybackGetPosition(ICEDVR_RecordingHandle *handle);


/**
 * @brief Set the number of seconds into the playback
 *
 * For a linear file this is the number of seconds from the start of
 * recording. Passing a negative value is undefined.
 *
 * For a circular file, a value of zero indicates the "oldest" part of
 * the recording.  Positive values indicate the number of seconds
 * forward in time from that point.  Negative values indicate the 
 * number of seconds backward in time from the current write point.
 * So -30 indicates "30 seconds ago", and -1 indicates the most recent
 * part of the recording (such that the read position is just behind
 * the write position with the minimum delay from the live broadcast).
 *
 * An "out of range" value sets the position to the closest valid value.
 *
 * @param handle Handle to the current playback.
 * @param seconds The number of seconds into the playback.
 * @return frost_true if the playback point has been set correctly, 
 *         otherwise frost_false.
 */
frost_bool ICEDVR_PlaybackSetTime(ICEDVR_RecordingHandle *handle,
                                  frost_int32 seconds);

/**
 * @brief Set the playback speed
 *
 * @param handle Handle to the current playback.
 * @param speed_per_thousandths Playback speed in per-thousandths. 
 *        Eg. 2000 is double speed, 500 is half speed, Pause is zero,
 *        -3000 is triple speed in reverse.
 * @note  The implementation will use the nearest supported speed to the
 *        speed requested by this function.
 * @return frost_true if the playback speed has been adjusted to be as close
 *         as possible to the requested speed, otherwise frost_false.
 */
frost_bool ICEDVR_PlaybackSetSpeed(ICEDVR_RecordingHandle *handle,
                                   frost_int32 speed_per_thousandths);

/**
 * @brief Get the current playback speed.
 *
 * @note This function retrieves the actual playback speed which may differ
 * from the request to ICEDVR_PlaybackSetSpeed().
 * @param handle Handle to the current playback.
 * @return The current playback speed in per-thousandths.
 *        Eg. 2000 is double speed, 500 is half speed,
 *        Pause is zero, -3000 is triple speed in reverse.
 */
frost_int32 ICEDVR_PlaybackGetSpeed(ICEDVR_RecordingHandle *handle);

/**
 * @brief Stop the playback.
 *
 * This function requests the stopping of a playback and returns.
 * When playback has successfully stopped then ICEDVR_PlaybackCallbackFunction
 * is called with 'icedvr_play_event_stopped'.
 *
 * If the handle was only playing back then the mode will be 'ice_dvr_none'.
 * On return from the callback the ICEDVR_RecordingHandle and any
 * allocated resources will be freed.
 *
 * If the handle was also recording then the mode will be 'ice_dvr_record_only'.
 * 
 * @param handle Handle to the playback.
 * @return frost_false if the recording id entry is not currently being played.
 */
frost_bool ICEDVR_PlaybackStop(ICEDVR_RecordingHandle *handle);

/**
 * @brief Opaque handle used when exporting a recording.
 *
 * The contents of this structure can be defined by the ICE implementer.
 */
typedef struct ICEDVR_ExportHandle ICEDVR_ExportHandle;

/**
 * @brief Starts exporting a recording.
 *
 * This is used to get the data for a recording out of the DVR engine.
 *
 * On USB platforms, this is used to export recordings to a file on a USB stick.
 * Eclipse uses this API to read the recording data from the DVR engine, and
 * the ice_filesystem.h APIs to write the data to the USB stick.  Eclipse will
 * only ever do one USB export at a time.
 *
 * In future, this may be used by UPnP to stream recordings over HTTP.  In this
 * case, multiple simultaneous exports may be requested (perhaps in multiple
 * threads).
 *
 * On platforms that store DVR recordings in a single file in a standard
 * format, then this call will just open the file for reading and
 * ICEDVR_ExportGetData() will just read data from the file.  On other
 * platforms, the data may need processing (e.g. to strip off non-standard
 * headers), and/or multiple smaller files may need to be read one after
 * another to get the whole recording.  This API provides a
 * platform-independent API to that platform-dependent functionality.
 *
 * @param descriptor The recording to export.
 * @return A handle to use for the export, or NULL on error (e.g. if
 *         'descriptor' does not specify a valid recording).
 */
ICEDVR_ExportHandle * ICEDVR_ExportStart(
        ICEDVR_RecordingDescriptor const *descriptor);

/**
 * @brief Gets some data for a recording.
 *
 * This reads some data from the DVR recording and writes it into the buffer.
 * The ICE implementation does not have to fill the buffer completely,
 * it may choose to send only some data.
 *
 * Eclipse will call this method repeatedly until either it returns EOF or
 * error, or until the user cancels.  Then Eclipse will call
 * ICEDVR_ExportClose().
 *
 * @param handle The handle from ICEDVR_ExportStart().
 * @param buffer The buffer where the data is to be written.
 * @param buffer_size The size of the buffer, in bytes.
 * @return If >0, indicates the number of bytes successfully copied into the
 *             buffer.
 *         If 0, indicates there is no more data - this export is complete
 *             and successful.
 *         If -1, indicates an unrecoverable error - Eclipse should close the
 *             handle and report failure.
 *         If <-1, indicates that the buffer is too small - the absolute
 *             value of the return code is the minimum required buffer size.
 *             Eclipse should try to allocate a bigger buffer and try again.
 */
frost_int32 ICEDVR_ExportGetData(ICEDVR_ExportHandle *handle, void *buffer,
                                 frost_int32 buffer_size);

/**
 * @brief Close a handle returned by ICEDVR_ExportStart().
 *
 * @param handle The handle to close.  If NULL, then this will do nothing.
 */
void ICEDVR_ExportClose(ICEDVR_ExportHandle *handle);

/**
 * @brief Gets the size that an exported recording will have.
 *
 * This calculates the number of bytes that will be returned by a series of
 * calls to ICEDVR_ExportGetData() for the specified recording.
 *
 * On platforms that store DVR recordings in a single file in a standard
 * format, then this call will just get the length of the file.
 *
 * Some ICE implementations may not be able to predict this accurately (e.g.
 * because ICEDVR_ExportGetData() slightly changes the format of the data); in
 * this case they can provide an estimate and set the "is approximate" flag
 * to frost_true.  Note that this approximation is used to check that
 * enough disk space is available on the USB stick, so a too-high approximation
 * may cause the user to get an "out of disk space" error when the export would
 * have succeeded; whereas a too-low approximation may cause the export to be
 * tried and then fail with an "out of disk space" error after a long time has
 * been spent copying the file.  ICE implementers should decide which behaviour
 * is least bad, and adjust their approximation appropriately.
 *
 * This approximation is also used to display the progress bar, so if it is
 * wrong then at the end the progress bar will "jump" or "get stuck".
 *
 * In future, this may be used by UPnP to stream recordings over HTTP.  In this
 * case, if an accurate size is provided then it will be used for the HTTP
 * Content-Length field; approximations will be ignored.
 *
 * @note An exported file will NOT necessarily have the size returned by
 *       ICEDVR_GetRecordingInfo().  This is because some platforms
 *       will do some conversion in their ICEDVR_ExportGetData() method,
 *       (e.g. throwing away platform-specific trick-mode hints) which might
 *       change the size.
 *
 * @param descriptor The recording that will be exported.
 * @param size_bytes_out On return, set to the size of the exported file
 *                       in bytes.  This may be set to an accurate value or
 *                       an approximation.
 * @param is_approximate_out On return, set to frost_true if 'size_bytes_out'
 *                           is accurate, or frost_false if 'size_bytes_out'
 *                           is an approximation.
 * @return frost_true on success, or frost_false on error (e.g. if
 *         'descriptor' does not specify a valid recording).
 */
frost_bool ICEDVR_ExportGetSize(ICEDVR_RecordingDescriptor const *descriptor,
                                frost_uint64s * size_bytes_out,
                                frost_bool * is_approximate_out);

/**
 * @brief Changes a "circular" timeslip recording to a "normal" linear
 *        recording.
 *
 * @note recording must be in progress for this call to succeed
 *
 * @param handle recording handle of circular recording. This should never be
 *               a linear/normal recording handle
 *
 * @return true if successful
 */
frost_bool ICEDVR_SwitchTimeslipToLinear(ICEDVR_RecordingHandle *handle);

/**
 * @brief Crops a recording to a new length.
 *
 * Typically used after a timeslip recording has been made linear.
 * The caller specifies the seconds into the recording that the new cropped
 * recording should now begin at.  Only the begining part of the recording is
 * cropped at present as this is the only requirement we have.
 *
 * @note  Recording must be stopped before attempting to crop
 *        
 * @param descriptor Recording descriptor as provided by Eclipse to
 *                   ICEDVR_RecordStart().
 * @param seconds_into_recording seconds into the recording that will become
 *                               the new start for the recording.
 *
 * @return true if successful
 */
frost_bool ICEDVR_CropLinearRecording(ICEDVR_RecordingDescriptor descriptor,
                                      frost_int32 seconds_into_recording);

frost_uint32 ICEDVR_USBSpeedTest(void);
frost_uint8 ICEDVR_PartitionFormatType(void);
void ICEDVR_SetEncryptionType(frost_uint8 type);
void ICE_NotifyPMTUpdateforRecording (int updatedVideoPid, int updateAudioPid, int updatedPCRPid);


#ifdef __cplusplus
}
#endif

#endif /* CABOT_ICE_ICE_DVR_H_INCLUDED*/
