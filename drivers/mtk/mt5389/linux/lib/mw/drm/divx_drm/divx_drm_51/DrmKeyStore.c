/*
// $Id: //DTV/MP_BR/DTV_X_IDTV0801_002150_7_001_11_001/chiling/driver/linux/lib/mw/drm/divx_drm/divx_drm_51/DrmKeyStore.c#1 $
// Copyright (c) 2005 DivX, Inc. http://www.divx.com/corporate
// All rights reserved.
//
// This software is the confidential and proprietary information of DivX
// Inc. ("Confidential Information").  You shall not disclose such Confidential
// Information and shall use it only in accordance with the terms of the license
// agreement you entered into with DivX, Inc.
*/


/*------------------------------------------------------------------------------------------
 *
 *  LOCAL INCLUDES
 *
 *-----------------------------------------------------------------------------------------*/
#ifndef __KERNEL__

#include "DrmKeyStore.h"
#include "DrmTypes.h"
#include "DrmApi.h"

#ifdef _MTK_BUILD_
#include "libc/memory.h"
#include "libc/string.h"
#include "libc/stdlib.h"
#else
#include <string.h>
#include <stdlib.h>
#endif

#else

#include "DrmKeyStore.h"
#include "DrmTypes.h"
#include "DrmApi.h"

#endif

/*------------------------------------------------------------------------------------------
 *
 *  DEFINES and MACROS
 *
 *-----------------------------------------------------------------------------------------*/
#define VALID_MESSAGE_KEY_TOTAL				14
#define MESSAGE_KEY_INDEX_TOTAL				16
    
static const uint8_t s_messageKeyTable[MESSAGE_KEY_INDEX_TOTAL][SIZEOF_MESSAGE_KEY_SIZE_BYTES] =
{
	{ 0xA1, 0xBD, 0x49, 0x71, 0xF8, 0x59, 0xCE, 0xFD, 0xDF, 0x9C, 0xAD, 0xE9, 0xA8, 0xE1, 0x16, 0xE4, 0x8E, 0x43, 0x9E, 0xA6 },
	{ 0x48, 0x34, 0x9B, 0x3A, 0x82, 0x42, 0x14, 0x7F, 0xB0, 0x98, 0xF6, 0x08, 0x9A, 0x64, 0x5A, 0x9E, 0xAC, 0xD7, 0x12, 0x65 },
	{ 0xDE, 0xC4, 0xE3, 0x8A, 0x72, 0x65, 0x72, 0x57, 0x28, 0x20, 0x70, 0x0A, 0x32, 0xCD, 0xF4, 0x5E, 0x5E, 0xA0, 0x1A, 0xDF },
	{ 0xEA, 0x17, 0x5D, 0xDC, 0x0C, 0x57, 0xF7, 0x8A, 0x4F, 0x5D, 0x28, 0x4E, 0x68, 0x07, 0xFD, 0x28, 0xBA, 0x58, 0x7C, 0x8C },
	{ 0x2C, 0xE1, 0x13, 0x3D, 0xD9, 0x77, 0xD9, 0x49, 0xB4, 0xFC, 0x9A, 0xDF, 0xBE, 0xBB, 0xE8, 0xB3, 0xE9, 0x66, 0xFB, 0xEC },
	{ 0xBA, 0xC1, 0x85, 0xFB, 0xA2, 0xFD, 0x75, 0x8F, 0xA4, 0x23, 0xB6, 0x14, 0x7D, 0xCB, 0xA5, 0xBB, 0x27, 0xBF, 0xAF, 0xA5 },
	{ 0x5B, 0x58, 0xC9, 0x17, 0xAA, 0xD6, 0x71, 0x42, 0xF6, 0xEB, 0xE5, 0x95, 0xB0, 0x03, 0x3C, 0xCB, 0x2C, 0x34, 0xF4, 0xF8 },
	{ 0xBE, 0x95, 0x81, 0x4E, 0x81, 0xDA, 0x57, 0x7C, 0xBC, 0x87, 0xCC, 0x0E, 0x99, 0x68, 0x75, 0xF9, 0x6E, 0x46, 0x15, 0x46 },
	{ 0xB8, 0xBC, 0x20, 0xB5, 0xD4, 0x00, 0xD3, 0x37, 0x1C, 0x93, 0x46, 0x00, 0x44, 0x18, 0x70, 0xCF, 0x99, 0x5F, 0xB7, 0xE3 },
	{ 0x8E, 0x1F, 0x70, 0xC8, 0x06, 0x43, 0x19, 0xE5, 0x66, 0xD6, 0x3B, 0x36, 0x4F, 0xCD, 0xCD, 0xC6, 0xA9, 0x8E, 0x47, 0xD8 },
	{ 0x45, 0x2F, 0xA0, 0x4B, 0x30, 0xAB, 0xDB, 0x09, 0x63, 0x67, 0xBD, 0xAB, 0x34, 0xEC, 0x04, 0x00, 0xB1, 0xCB, 0xEA, 0xBE },
	{ 0xDF, 0xED, 0xB5, 0xC7, 0x9C, 0x7F, 0x82, 0x1C, 0x3F, 0xC8, 0x5B, 0x22, 0x34, 0x79, 0xFD, 0xC2, 0x10, 0x42, 0x16, 0x9A },
	{ 0xFD, 0xA3, 0x49, 0x81, 0x95, 0x30, 0x87, 0x01, 0x80, 0x6D, 0xCA, 0xFD, 0x68, 0x7E, 0x16, 0x23, 0xBF, 0x87, 0x56, 0xA6 },
	{ 0xEB, 0x51, 0x5F, 0x6A, 0x06, 0xFD, 0x19, 0x62, 0x96, 0xCD, 0xED, 0xB8, 0xD8, 0xC6, 0x86, 0x86, 0xD9, 0x29, 0x0D, 0x34 },
	{ 0x4E, 0xA4, 0x90, 0x9A, 0x83, 0x42, 0x14, 0x7F, 0xB0, 0x98, 0xF6, 0x08, 0x9A, 0x64, 0x5A, 0x9E, 0xAC, 0xD7, 0x12, 0x65 },
	{ 0x09, 0xBC, 0x09, 0x7E, 0xA8, 0x59, 0xCE, 0xFD, 0xDF, 0x9C, 0xAD, 0xE9, 0xA8, 0xE1, 0x16, 0xE4, 0x8E, 0x43, 0x9E, 0xA6 }
};

static const uint8_t initUserId[OWNER_USER_ID_BYTES] = { 0xAC, 0xAC, 0xAC, 0xAC, 0xAC};

/*------------------------------------------------------------------------------------------
 *
 *  FUNCTIONAL DEFINITION
 *
 *-----------------------------------------------------------------------------------------*/
int32_t keyStoreGetProtectionFormat( uint8_t *protectionFormatFlag,
                                     uint8_t* message )
{
	uint8_t userId[OWNER_USER_ID_BYTES + 1] = {0};
	/* uint8_t userNull[OWNER_USER_ID_BYTES] = {0, 0, 0, 0, 0}; */
	uint8_t userDeactivated[OWNER_USER_ID_BYTES] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
	int32_t result = KEY_STORE_ERROR_GENERAL;
    uint32_t userIdLength = OWNER_USER_ID_BYTES + 1;

	if ( NULL != protectionFormatFlag )
	{
        result = drmGetActivationStatus( userId, &userIdLength );
        if(result == DRM_NOT_REGISTERED)
        {
            *protectionFormatFlag = 0;
        }
        else if(result == DRM_SUCCESS)
        {   
            result = 0;

            /*         
            deactivated user shows that the device has been activated, 
            then deactivated, so we signal in the reg code with protection
            format 1.

            the init user indicates that the device has never been activated
            so we signal with protection format 0

            a valid user indicates that the device is currently activated, so 
            we return an error, a reg code should not be displayed while activated.

            */
            if(memcmp(userId, userDeactivated, OWNER_USER_ID_BYTES) == 0)
            {
                *protectionFormatFlag = 1;
            }
            
            else if(memcmp(userId, initUserId, OWNER_USER_ID_BYTES) == 0)
            {
                *protectionFormatFlag = 0;
            }
            else
            {
                *protectionFormatFlag = 1;/*if this is set to error out, reg codes will not be provided*/
            	result = KEY_STORE_ERROR_ALREADY_ACTIVATED;
            }
        } 
	}
	return result;
}

/*
 *
 */
int32_t keyStoreGetMessageKey( uint8_t protectionFormatFlag,
                               uint8_t *messageKey )
{
	int32_t result = -1;

	if ( !(protectionFormatFlag > (MESSAGE_KEY_INDEX_TOTAL - 1)) )
	{
		memcpy( messageKey,
                s_messageKeyTable[protectionFormatFlag],
                SIZEOF_MESSAGE_KEY_SIZE_BYTES );
		result = 0;
	}

	return result;
}

