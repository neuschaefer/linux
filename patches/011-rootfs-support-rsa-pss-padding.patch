diff --git a/init/nfsb/nfsb.c b/init/nfsb/nfsb.c
index 68cbe30..ff3ff94 100644
--- a/init/nfsb/nfsb.c
+++ b/init/nfsb/nfsb.c
@@ -18,6 +18,7 @@
 #include "rsa.h"
 
 static const char MAGIC[] = { 'N', 'F', 'S', 'B' };
+static const unsigned char zeroes[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
 static const ssize_t BYTES_PER_SECTOR = 512;
 
@@ -71,6 +72,279 @@ const char *nfsb_verity_hash(const struct nfsb_header *h)
 	return h->verity_hash;
 }
 
+/* pkcs1 padding signature check
+ * reserved, alternative
+ */
+int nfsb_pkcs1_verify(uint8_t *msg, uint8_t* hash)
+{
+	/**
+	*padding check:
+	*padding len is 224bytes: (first 2 and last 20bytes) are not 0xff ,all other is padding with 0xff :
+	* { 0,0x1,0xff,0xff,...0xff,0x00, 0x30, 0x31, 0x30,0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01
+	*  , 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20}
+	**/
+	#define PADDING_FF_LEN 182
+	const uint8_t padding[RSA_LEN - SHA256_LEN - PADDING_FF_LEN] = {
+		0x00, 0x01, 0x00, 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
+		0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20
+	};
+	int pad_len = RSA_LEN - SHA256_LEN;
+	int i = 0;
+
+	for(i=0;i<pad_len;i++)
+	{
+		if(i<2){
+			if(msg[i] != padding[i]){
+				pr_err("RSA check padding fail first two!\n");
+				return -EINVAL;
+			}
+		}
+		else if(i>203){
+			if(msg[i] != padding[i-203 +1]){
+				pr_err("RSA check padding fail last 20!\n");
+				return -EINVAL;
+			}
+		}
+		else {
+				if(msg[i] != 0xff){
+				pr_err("RSA check padding fail not 0xff!\n");
+				return -EINVAL;
+			}
+
+		}
+	}
+
+	/* compare calculate hash and rsa hash. */
+	if (memcmp((uint8_t *)msg + pad_len, hash, SHA256_LEN)) {
+		pr_err("RSA check hash fail!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Mask Generation Function
+ * mask:      mask out
+ * len:       maskedDBLen
+ * seed:      input hash
+ * seedlen:   input hash len
+ * hash_algo: hash algorithm
+ */
+int pkcs1_mfg1(unsigned char *mask, long len, const unsigned char *seed, long seedlen, char *hash_algo)
+{
+	/* for hash algorithm */
+	struct crypto_hash *tfm = NULL;
+	struct hash_desc desc;
+	struct scatterlist sg[1];
+
+	unsigned char cnt[4];
+	unsigned char md[64];   // longest known is SHA512
+	unsigned int mdlen = 0;
+	long i, outlen = 0;
+	int ret = -1;
+
+	/* Initialize hash algorithm . */
+	tfm = crypto_alloc_hash(hash_algo, 0, 0);
+	if (IS_ERR(tfm)) {
+		pr_err("Failed to load transform for sha256: %ld\n", PTR_ERR(tfm));
+		return ret;
+	}
+	mdlen = crypto_hash_digestsize(tfm);   // if sha256, 32
+	desc.tfm = tfm;
+	desc.flags = 0;
+
+	for (i = 0; outlen < len; i++) {
+		cnt[0] = (unsigned char)((i >> 24) & 255);
+		cnt[1] = (unsigned char)((i >> 16) & 255);
+		cnt[2] = (unsigned char)((i >> 8)) & 255;
+		cnt[3] = (unsigned char)(i & 255);
+
+		/* Hash(seed || cnt) */
+		ret = crypto_hash_init(&desc);
+		if (ret) {
+			pr_alert("crypto_hash_init failure: %d\n", ret);
+			goto failure;
+		}
+		sg_init_one(sg, seed, seedlen);
+		ret = crypto_hash_update(&desc, sg, seedlen);
+		if (ret) {
+			pr_alert("crypto_hash_update seed failure: %d\n", ret);
+			goto failure;
+		}
+		sg_init_one(sg, cnt, 4);
+		ret = crypto_hash_update(&desc, sg, 4);
+		if (ret) {
+			pr_alert("crypto_hash_update cnt failure: %d\n", ret);
+			goto failure;
+		}
+		ret = crypto_hash_final(&desc, md);
+		if (ret) {
+			pr_alert("crypto_hash_final failure: %d\n", ret);
+			goto failure;
+		}
+
+		/* mask_out += mdigest */
+		if (outlen + mdlen <= len) {                //out + 32 <= maskedDBLen(256-32-1)
+			memcpy(mask + outlen, md, mdlen);
+			outlen += mdlen;
+		} else {
+			memcpy(mask + outlen, md, len - outlen);
+			outlen = len;
+		}
+	}
+	ret = 0;
+failure:
+	crypto_free_hash(tfm);
+	return ret;
+}
+
+int nfsb_rsa_pss_verify(uint8_t *EM, uint8_t* mHash)
+{
+	unsigned char DB[RSA_LEN] = {0};
+	unsigned char Hcal[SHA256_LEN] = {0};
+	const unsigned char *H;
+	int maskedDBLen, MSBits, emLen;
+	int hLen = SHA256_LEN;
+	int sLen = SHA256_LEN;
+	int j, i = 0;
+	int ret = -1;
+	/* for hash algorithm */
+	struct crypto_hash *tfm = NULL;
+	struct hash_desc desc;
+	struct scatterlist sg[1];
+#ifdef ARC_DEBUG
+	char sha256_hash[65] = {0};
+	char rsa_data[513] = {0};
+	char *s = NULL;
+
+	s = sha256_hash;
+	for(i = 0; i < SHA256_LEN; i++, s+=2)
+		sprintf(s, "%02X", mHash[i]);
+	pr_alert("nfsb header sha256: %s\n", sha256_hash);
+
+	s = rsa_data;
+	for(i = 0; i < RSA_LEN; i++, s+=2)
+		sprintf(s, "%02X", EM[i]);
+	pr_alert("pss padding result: %s\n", rsa_data);
+#endif
+
+	MSBits = (RSA_LEN - 1) & 0x7;    //0x7
+	emLen = RSA_LEN;
+	if (EM[0] & (0xFF << MSBits)) {  //0xFF << 0x7 = 0x80
+		pr_alert("Verify MSBits failed!\n");
+		goto err;
+	}
+	if (MSBits == 0) {
+		EM++;
+		emLen--;
+	}
+	if (emLen < hLen + 2) {
+		pr_alert("Verify data too large\n");
+		goto err;
+	}
+	if (sLen > emLen - hLen - 2) {
+		pr_alert("Verify data too large\n");
+		goto err;
+	}
+	if (EM[emLen - 1] != 0xbc) {
+		pr_alert("Verify last octet failed!\n");
+		goto err;
+	}
+	maskedDBLen = emLen - hLen - 1;                 //256-32-1=223
+	H = EM + maskedDBLen;                           //The hash in EM=MaskedDB|H|0xbc
+	if (pkcs1_mfg1(DB, maskedDBLen, H, hLen, "sha256") != 0)    //generate mask according to H
+		goto err;
+	for (i = 0; i < maskedDBLen; i++)
+		DB[i] ^= EM[i];
+	if (MSBits)
+		DB[0] &= 0xFF >> (8 - MSBits);                // &= 0x7F
+
+	/* get salt offset and check salt len
+	 * DB = |0x00 x 190|0x01|salt|
+	 */
+	for (i = 0; DB[i] == 0 && i < (maskedDBLen - 1); i++) ;
+	if (DB[i++] != 0x1) {
+		pr_alert("salt len recovery failed!\n");
+		goto err;
+	}
+	if (sLen >= 0 && (maskedDBLen - i) != sLen) {
+		pr_alert("salt len check failed!\n");
+		goto err;
+	}
+
+#ifdef ARC_DEBUG
+	pr_alert("i=%d, maskedDBLen-i=%d\n", i, maskedDBLen - i);
+
+	/* dump DB */
+	s = rsa_data;
+	for(j = 0; j < maskedDBLen; j++, s += 2)
+		sprintf(s, "%02X", DB[j]);
+	pr_alert("DB result: %s\n", rsa_data);
+#endif
+
+	/* Hash(0x00 x 8 || mHash || salt) */
+	tfm = crypto_alloc_hash("sha256", 0, 0);  //Initialize SHA-256.
+	if (IS_ERR(tfm)) {
+		pr_alert("Failed to load transform for sha256: %ld\n", PTR_ERR(tfm));
+		goto err;
+	}
+	desc.tfm = tfm;
+	desc.flags = 0;
+	ret = crypto_hash_init(&desc);
+	if (ret) {
+		pr_alert("crypto_hash_init failure: %d\n", ret);
+		goto err;
+	}
+	/* hash 0x00 x 8 */
+	sg_init_one(sg, zeroes, sizeof(zeroes));
+	ret = crypto_hash_update(&desc, sg, sizeof(zeroes));
+	if (ret) {
+		pr_alert("crypto_hash_update zeroes failure: %d\n", ret);
+		goto err;
+	}
+	/* hash mHash */
+	sg_init_one(sg, mHash, hLen);
+	ret = crypto_hash_update(&desc, sg, hLen);
+	if (ret) {
+		pr_alert("crypto_hash_update nfsb header hash failure: %d\n", ret);
+		goto err;
+	}
+	/* hash salt */
+	if (maskedDBLen - i) {
+		sg_init_one(sg, DB + i, maskedDBLen - i);                 //sg_init_one(sg, DB+191, 32)
+		ret = crypto_hash_update(&desc, sg, maskedDBLen - i);
+		if (ret) {
+			pr_alert("crypto_hash_update salt failure: %d\n", ret);
+			goto err;
+		}
+	}
+	ret = crypto_hash_final(&desc, Hcal);
+	if (ret) {
+		pr_alert("crypto_hash_final failure: %d\n", ret);
+		goto err;
+	}
+	/* end of Hash(0x00 x 8 || FW hash || salt) */
+
+#ifdef ARC_DEBUG
+	s = rsa_data;
+	for(i = 0; i < hLen; i++, s += 2)
+		sprintf(s, "%02X", Hcal[i]);
+	printk(KERN_ALERT "Calculate H result: %s\n", rsa_data);
+#endif
+
+	if (memcmp(Hcal, H, hLen) == 0) {
+		pr_alert("Signature check ok!\n");
+		ret = 0;
+	} else {
+		pr_alert("Signature check failed!\n");
+		ret = -1;
+	}
+
+err:
+	crypto_free_hash(tfm);
+	return ret;
+}
+
 int nfsb_verify(const struct nfsb_header *h, const uint8_t *key, const uint8_t *n)
 {
 	struct crypto_hash *tfm = NULL;
@@ -117,7 +391,7 @@ int nfsb_verify(const struct nfsb_header *h, const uint8_t *key, const uint8_t *
 		goto failure;
 	}
 
-	if (!memcmp(&msg[RSA_LEN - SHA256_LEN], digest, SHA256_LEN))
+	if (!nfsb_rsa_pss_verify(msg, digest))
 		ret = 0;
 	else
 		ret = -1;
